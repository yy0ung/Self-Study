# OS 컴파일러 기본

<br>

### 1. **Compile**

- 소스코드 (C, C++, JAVA 등) 를 CPU 가 이해할 수 있는 기계어로 변환하는 작업. (소스코드 → 목적코드)
- 컴파일 결과 기계어로 이루어진 실행 파일이 생기며, 이를 실행하면 프로그램이 동작함.
- 코드 작성 → 실행까지
    
    <aside>
    ✅ 코드 작성 ( **컴파일** ) 오브젝트 파일 ( **링킹** ) 실행 파일 ( **로드** ) 메모리 적재 후 수행
    
    </aside>
    
<br><br>

### 2. **컴파일러의 구문분석**

- `tokenizer` , `lexer` , `parser` 를 거쳐서 실행됨.
- 구문분석 과정이 완료되면 그 결과를 바탕으로 `AST` 가 생성됨.

<br>

- `tokenizer`
    - 어떤 의미를 가지는 요소들을 토큰으로 쪼개는 단계
    - 기준이 정해진 것은 아님. 단어나 단어구 등의 의미있는 단위로 주로 쪼갬.
- `lexer`
    - 쪼갠 토큰의 의미를 분석하는 단계
    - 의미있는 조각을 검출하여 토큰을 생성하는 단계
    - `tokenizer` 단계와 합쳐서 `Lexcial analyze` 를 이룸.
- `parser`
    - 토큰화된 데이터를 가지고 구조적으로 나타내는 단계.
    - 데이터 검증까지 함께하는 단계로 `Syntax Analyze` 를 이룸.
    - 도출된 결과는 `AST` 로 생성됨.
    - 결과적으로 기계어로 변환되기 직전까지의 과정을 담당함.

<br>

- `AST` (Abstract Syntax Tree)
    - abstract 하게 작성된 parsing tree.
    - 구문분석 과정을 거쳐 생성된 트리로, 작성한 소스코드를 컴퓨터가 이해할 수 있도록 구조화한 것.
    - Abstract 이라고 표현하는 이유?
        - 불필요한 단어는 제외하고 꼭 필요한 데이터만 나타내기 때문에 추상적이라고 표현.
        - 표현할 때 공백, 기호, 세미콜론 등은 표현하지 않음.

<br><br>

### 3. **링킹**

- 컴파일러는 기계어로 이루어진 파일인 object 파일을 생성하는데, 이는 소스코드와 실행파일의 중간단계.
- Object 파일들과 라이브러리 파일을 합쳐서, 이를 링커가 링킹하여 실행파일로 만듦.
    
    <img width="487" alt="스크린샷 2023-08-08 오전 12 26 04" src="https://user-images.githubusercontent.com/82799840/258852192-ca291164-5a17-42bf-bc1a-9c9806438a04.png">

    
- 즉 컴파일과정과 링킹 과정을 거치면 사용자가 실행 가능한 실행파일이 생성됨.
- 사용자가 실행하게 되면 Loader 가 이를 메모리에 적재하여 실행 가능하게 함.